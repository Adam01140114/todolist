<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Todo List App</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <!-- Authentication Modal -->
    <div id="authModal" class="auth-modal">
        <div class="auth-container">
            <div class="auth-header">
                <h2><i class="fas fa-tasks"></i> Todo List</h2>
                <p>Sign in to access your personal todo list</p>
            </div>
            
            <div class="auth-tabs">
                <button class="auth-tab active" id="loginTab">Sign In</button>
                <button class="auth-tab" id="signupTab">Sign Up</button>
            </div>

            <form id="authForm" class="auth-form">
                <div class="form-group">
                    <input type="email" id="email" placeholder="Email address" required>
                </div>
                <div class="form-group">
                    <input type="password" id="password" placeholder="Password" required>
                </div>
                <button type="submit" class="auth-btn" id="authSubmitBtn">
                    <span id="authBtnText">Sign In</span>
                    <div class="auth-spinner" id="authSpinner" style="display: none;"></div>
                </button>
            </form>

            <div class="auth-error" id="authError" style="display: none;"></div>
        </div>
    </div>

    <div class="app-container" id="appContainer" style="display: none;">
        <header class="app-header">
            <h1><i class="fas fa-tasks"></i> My Todo List</h1>
            <div class="header-actions">
                <div class="stats">
                    <span class="total-todos">0</span> tasks
                </div>
                <button class="logout-btn" onclick="app.signOut()" title="Sign Out">
                    <i class="fas fa-sign-out-alt"></i>
                </button>
            </div>
        </header>

        <div class="app-error" id="appError" style="display: none;"></div>

        <div class="add-todo-section">
            <div class="input-container">
                <input type="text" id="todoInput" placeholder="Add a new task...">
                <button id="addBtn" class="add-btn">
                    <i class="fas fa-plus"></i>
                </button>
            </div>
        </div>

        <div class="todos-container">
            <div class="todos-section">
                <h2 class="section-title">
                    <i class="fas fa-star"></i> Important Tasks
                    <span class="count" id="importantCount">0</span>
                </h2>
                <div id="importantTodos" class="todo-list important-list">
                    <!-- Important todos will be added here -->
                </div>
            </div>

            <div class="todos-section">
                <h2 class="section-title">
                    <i class="fas fa-list"></i> All Tasks
                    <span class="count" id="allCount">0</span>
                </h2>
                <div id="allTodos" class="todo-list all-list">
                    <!-- Regular todos will be added here -->
                </div>
            </div>
        </div>

        <div class="empty-state" id="emptyState">
            <i class="fas fa-clipboard-list"></i>
            <h3>YOU CURRENTLY HAVE NO TASKS</h3>
        </div>
    </div>

    <!-- Loading overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-spinner"></div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, push, onValue, remove, update, get } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';

        const firebaseConfig = {
            apiKey: "AIzaSyCZUp1CSYlsVgzhttkziCLWEnReTw8dm68",
            authDomain: "todolis-a32fe.firebaseapp.com",
            projectId: "todolis-a32fe",
            storageBucket: "todolis-a32fe.firebasestorage.app",
            messagingSenderId: "129292823003",
            appId: "1:129292823003:web:40c8154872e8740c1edffe",
            measurementId: "G-T9DDSCTQFX",
            databaseURL: "https://todolis-a32fe-default-rtdb.firebaseio.com/"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        const auth = getAuth(app);

        class TodoApp {
            constructor() {
                this.todos = [];
                this.user = null;
                this.todosRef = null;
                this.initializeElements();
                this.setupEventListeners();
                this.setupAuth();
            }

            initializeElements() {
                this.todoInput = document.getElementById('todoInput');
                this.addBtn = document.getElementById('addBtn');
                this.importantTodos = document.getElementById('importantTodos');
                this.allTodos = document.getElementById('allTodos');
                this.emptyState = document.getElementById('emptyState');
                this.loadingOverlay = document.getElementById('loadingOverlay');
                this.totalTodos = document.querySelector('.total-todos');
                this.importantCount = document.getElementById('importantCount');
                this.allCount = document.getElementById('allCount');
                this.appError = document.getElementById('appError');
                this.todosContainer = document.querySelector('.todos-container');
                
                // Auth elements
                this.authModal = document.getElementById('authModal');
                this.appContainer = document.getElementById('appContainer');
                this.authForm = document.getElementById('authForm');
                this.emailInput = document.getElementById('email');
                this.passwordInput = document.getElementById('password');
                this.authSubmitBtn = document.getElementById('authSubmitBtn');
                this.authBtnText = document.getElementById('authBtnText');
                this.authSpinner = document.getElementById('authSpinner');
                this.authError = document.getElementById('authError');
                this.loginTab = document.getElementById('loginTab');
                this.signupTab = document.getElementById('signupTab');
            }

            setupEventListeners() {
                this.addBtn.addEventListener('click', () => this.addTodo());
                this.todoInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.addTodo();
                });

                // Add event delegation for sublist inputs
                document.addEventListener('keypress', (e) => {
                    if (e.target.id && e.target.id.startsWith('subtaskInput-') && e.key === 'Enter') {
                        const todoId = e.target.id.replace('subtaskInput-', '');
                        this.addSubtask(todoId);
                    }
                });

                // Auth event listeners
                this.authForm.addEventListener('submit', (e) => this.handleAuth(e));
                this.loginTab.addEventListener('click', () => this.switchAuthMode('login'));
                this.signupTab.addEventListener('click', () => this.switchAuthMode('signup'));
            }

            setupAuth() {
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        this.user = user;
                        this.todosRef = ref(database, `users/${user.uid}/todos`);
                        this.showApp();
                        this.loadTodos();
                    } else {
                        this.user = null;
                        this.todosRef = null;
                        this.showAuth();
                    }
                });
            }

            showAuth() {
                this.authModal.style.display = 'flex';
                this.appContainer.style.display = 'none';
            }

            showApp() {
                this.authModal.style.display = 'none';
                this.appContainer.style.display = 'block';
            }

            switchAuthMode(mode) {
                const isLogin = mode === 'login';
                this.loginTab.classList.toggle('active', isLogin);
                this.signupTab.classList.toggle('active', !isLogin);
                this.authBtnText.textContent = isLogin ? 'Sign In' : 'Sign Up';
                this.authError.style.display = 'none';
            }

            async handleAuth(e) {
                e.preventDefault();
                const email = this.emailInput.value.trim();
                const password = this.passwordInput.value;
                const isLogin = this.loginTab.classList.contains('active');

                this.showAuthLoading(true);
                this.hideError();

                try {
                    if (isLogin) {
                        await signInWithEmailAndPassword(auth, email, password);
                    } else {
                        await createUserWithEmailAndPassword(auth, email, password);
                    }
                } catch (error) {
                    this.showError(this.getAuthErrorMessage(error.code));
                } finally {
                    this.showAuthLoading(false);
                }
            }

            async signOut() {
                try {
                    await signOut(auth);
                } catch (error) {
                    console.error('Error signing out:', error);
                }
            }

            showAuthLoading(show) {
                this.authSubmitBtn.disabled = show;
                this.authBtnText.style.display = show ? 'none' : 'block';
                this.authSpinner.style.display = show ? 'block' : 'none';
            }

            showError(message) {
                this.authError.textContent = message;
                this.authError.style.display = 'block';
            }

            hideError() {
                this.authError.style.display = 'none';
            }

            getAuthErrorMessage(errorCode) {
                switch (errorCode) {
                    case 'auth/user-not-found':
                        return 'No account found with this email address.';
                    case 'auth/wrong-password':
                        return 'Incorrect password.';
                    case 'auth/email-already-in-use':
                        return 'An account with this email already exists.';
                    case 'auth/weak-password':
                        return 'Password should be at least 6 characters.';
                    case 'auth/invalid-email':
                        return 'Invalid email address.';
                    default:
                        return 'Authentication failed. Please try again.';
                }
            }

            async loadTodos() {
                if (!this.todosRef) return;
                
                this.showLoading(true);
                
                // Set up a timeout to ensure loading doesn't stay forever
                const loadingTimeout = setTimeout(() => {
                    console.warn('Loading todos took too long, hiding spinner');
                    this.showLoading(false);
                }, 10000); // 10 second timeout
                
                try {
                    // First, get the initial data
                    const snapshot = await get(this.todosRef);
                    this.todos = [];
                    if (snapshot.exists()) {
                        const data = snapshot.val();
                        Object.keys(data).forEach(key => {
                            this.todos.push({ id: key, ...data[key] });
                        });
                    }
                    this.renderTodos();
                    this.updateStats();
                    this.showLoading(false);
                    clearTimeout(loadingTimeout);
                    
                    // Then set up real-time listener for updates
                    onValue(this.todosRef, (snapshot) => {
                        this.todos = [];
                        if (snapshot.exists()) {
                            const data = snapshot.val();
                            Object.keys(data).forEach(key => {
                                this.todos.push({ id: key, ...data[key] });
                            });
                        }
                        this.renderTodos();
                        this.updateStats();
                    }, (error) => {
                        console.error('Error in real-time listener:', error);
                    });
                } catch (error) {
                    console.error('Error loading todos:', error);
                    this.showLoading(false);
                    clearTimeout(loadingTimeout);
                    
                    // Show user-friendly error message
                    if (error.code === 'PERMISSION_DENIED' || error.message?.includes('Permission denied')) {
                        this.showAppError('Database permission denied. Please update your Firebase security rules. See database.rules.json file for the correct rules.');
                    } else {
                        this.showAppError('Failed to load todos. Please try refreshing the page.');
                    }
                }
            }

            async addTodo() {
                const text = this.todoInput.value.trim();
                if (!text || !this.todosRef) return;

                const todo = {
                    text: text,
                    completed: false,
                    important: false,
                    createdAt: Date.now(),
                    order: this.todos.length
                };

                try {
                    await push(this.todosRef, todo);
                    this.todoInput.value = '';
                } catch (error) {
                    console.error('Error adding todo:', error);
                }
            }

            async toggleImportant(todoId) {
                const todo = this.todos.find(t => t.id === todoId);
                if (!todo || !this.todosRef) return;

                const todoRef = ref(database, `users/${this.user.uid}/todos/${todoId}`);
                await update(todoRef, { important: !todo.important });
            }

            async toggleCompleted(todoId) {
                const todo = this.todos.find(t => t.id === todoId);
                if (!todo || !this.todosRef) return;

                const todoRef = ref(database, `users/${this.user.uid}/todos/${todoId}`);
                await update(todoRef, { completed: !todo.completed });
            }

            async deleteTodo(todoId) {
                if (!this.todosRef) return;
                const todoRef = ref(database, `users/${this.user.uid}/todos/${todoId}`);
                await remove(todoRef);
            }

            toggleSublist(todoId) {
                const sublistContainer = document.getElementById(`sublist-${todoId}`);
                const sublistBtn = document.querySelector(`[onclick="app.toggleSublist('${todoId}')"]`);
                
                if (sublistContainer.style.display === 'none') {
                    sublistContainer.style.display = 'block';
                    sublistBtn.classList.add('active');
                    
                    // Re-render subtasks when opening sublist
                    const todo = this.todos.find(t => t.id === todoId);
                    if (todo && todo.subtasks) {
                        this.renderSubtasks(todoId, todo.subtasks);
                    }
                } else {
                    sublistContainer.style.display = 'none';
                    sublistBtn.classList.remove('active');
                }
            }

            async addSubtask(todoId) {
                const input = document.getElementById(`subtaskInput-${todoId}`);
                const text = input.value.trim();
                if (!text || !this.todosRef) return;

                const todo = this.todos.find(t => t.id === todoId);
                if (!todo) return;

                const subtasks = todo.subtasks || [];
                const newSubtask = {
                    id: Date.now().toString(),
                    text: text,
                    completed: false,
                    createdAt: Date.now()
                };

                subtasks.push(newSubtask);

                const todoRef = ref(database, `users/${this.user.uid}/todos/${todoId}`);
                await update(todoRef, { subtasks: subtasks });

                input.value = '';
                
                // Re-render subtasks immediately
                this.renderSubtasks(todoId, subtasks);
            }

            async toggleSubtask(todoId, subtaskId) {
                const todo = this.todos.find(t => t.id === todoId);
                if (!todo || !this.todosRef) return;

                const subtasks = todo.subtasks || [];
                const subtask = subtasks.find(s => s.id === subtaskId);
                if (!subtask) return;

                // Don't allow toggling completion for crossed-out subtasks
                if (subtask.crossedOut) return;

                subtask.completed = !subtask.completed;

                // Update local state immediately
                todo.subtasks = subtasks;

                const todoRef = ref(database, `users/${this.user.uid}/todos/${todoId}`);
                await update(todoRef, { subtasks: subtasks });
                
                // Re-render subtasks immediately
                this.renderSubtasks(todoId, subtasks);
            }

            async deleteSubtask(todoId, subtaskId) {
                const todo = this.todos.find(t => t.id === todoId);
                if (!todo || !this.todosRef) return;

                const subtasks = todo.subtasks || [];
                const subtask = subtasks.find(s => s.id === subtaskId);
                if (!subtask) return;

                // If already crossed out, delete it permanently
                if (subtask.crossedOut) {
                    const filteredSubtasks = subtasks.filter(s => s.id !== subtaskId);
                    const todoRef = ref(database, `users/${this.user.uid}/todos/${todoId}`);
                    await update(todoRef, { subtasks: filteredSubtasks });
                    
                    // Update local state immediately
                    todo.subtasks = filteredSubtasks;
                    
                    // Re-render subtasks immediately
                    this.renderSubtasks(todoId, filteredSubtasks);
                } else {
                    // First click: mark as crossed out
                    subtask.crossedOut = true;
                    const todoRef = ref(database, `users/${this.user.uid}/todos/${todoId}`);
                    await update(todoRef, { subtasks: subtasks });
                    
                    // Update local state immediately
                    todo.subtasks = subtasks;
                    
                    // Re-render subtasks immediately
                    this.renderSubtasks(todoId, subtasks);
                }
            }

            renderSubtasks(todoId, subtasks) {
                const container = document.getElementById(`sublistItems-${todoId}`);
                if (!container) return;

                container.innerHTML = '';

                subtasks.forEach(subtask => {
                    const subtaskElement = document.createElement('div');
                    const isCrossedOut = subtask.crossedOut || false;
                    subtaskElement.className = `subtask-item ${subtask.completed ? 'completed' : ''} ${isCrossedOut ? 'crossed-out' : ''}`;
                    subtaskElement.dataset.subtaskId = subtask.id;
                    subtaskElement.dataset.todoId = todoId;
                    
                    const deleteTitle = isCrossedOut ? 'Delete permanently' : 'Cross out';
                    
                    // Create complete button
                    const completeBtn = document.createElement('button');
                    completeBtn.className = `subtask-complete-btn ${subtask.completed ? 'completed' : ''}`;
                    completeBtn.onclick = () => this.toggleSubtask(todoId, subtask.id);
                    if (isCrossedOut) {
                        completeBtn.disabled = true;
                        completeBtn.style.opacity = '0.3';
                        completeBtn.style.cursor = 'not-allowed';
                    }
                    completeBtn.innerHTML = '<i class="fas fa-check"></i>';
                    
                    // Create text element with double-click handler
                    const textElement = document.createElement('span');
                    textElement.className = 'subtask-text';
                    textElement.textContent = subtask.text;
                    textElement.title = 'Double-click to edit';
                    if (!isCrossedOut) {
                        textElement.addEventListener('dblclick', (e) => {
                            e.stopPropagation();
                            this.startEditSubtask(todoId, subtask.id);
                        });
                    }
                    
                    // Create delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'subtask-delete-btn';
                    deleteBtn.title = deleteTitle;
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        this.deleteSubtask(todoId, subtask.id);
                    };
                    deleteBtn.innerHTML = '<i class="fas fa-times"></i>';
                    
                    // Assemble the element
                    subtaskElement.appendChild(completeBtn);
                    subtaskElement.appendChild(textElement);
                    subtaskElement.appendChild(deleteBtn);
                    
                    container.appendChild(subtaskElement);
                });
            }

            async updateOrder(todoId, newOrder) {
                if (!this.todosRef) return;
                const todoRef = ref(database, `users/${this.user.uid}/todos/${todoId}`);
                await update(todoRef, { order: newOrder });
            }

            startEditTodo(todoId) {
                const todoElement = document.querySelector(`[data-todo-id="${todoId}"]`);
                if (!todoElement) return;

                const textElement = todoElement.querySelector('.todo-text');
                if (!textElement) return;

                const currentText = textElement.textContent;
                
                // Create input element
                const input = document.createElement('input');
                input.type = 'text';
                input.value = currentText;
                input.className = 'todo-edit-input';
                
                // Replace text with input
                textElement.style.display = 'none';
                textElement.parentNode.insertBefore(input, textElement);
                
                // Focus and select text
                input.focus();
                input.select();
                
                // Handle save on Enter or blur
                const saveEdit = async () => {
                    const newText = input.value.trim();
                    if (newText && newText !== currentText) {
                        await this.updateTodoText(todoId, newText);
                    }
                    // Restore text element
                    textElement.textContent = newText || currentText;
                    textElement.style.display = '';
                    input.remove();
                };
                
                const cancelEdit = () => {
                    textElement.style.display = '';
                    input.remove();
                };
                
                input.addEventListener('blur', saveEdit);
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        saveEdit();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        cancelEdit();
                    }
                });
            }

            async updateTodoText(todoId, newText) {
                if (!this.todosRef) return;
                const todoRef = ref(database, `users/${this.user.uid}/todos/${todoId}`);
                await update(todoRef, { text: newText });
            }

            startEditSubtask(todoId, subtaskId) {
                // Try to find the subtask element - use more specific selector
                const container = document.getElementById(`sublistItems-${todoId}`);
                if (!container) return;
                
                const subtaskElement = container.querySelector(`[data-subtask-id="${subtaskId}"]`);
                if (!subtaskElement) {
                    console.warn('Subtask element not found:', subtaskId);
                    return;
                }

                const textElement = subtaskElement.querySelector('.subtask-text');
                if (!textElement) {
                    console.warn('Subtask text element not found');
                    return;
                }

                // Don't allow editing crossed-out subtasks
                if (subtaskElement.classList.contains('crossed-out')) return;

                const currentText = textElement.textContent;
                
                // Create input element
                const input = document.createElement('input');
                input.type = 'text';
                input.value = currentText;
                input.className = 'todo-edit-input';
                
                // Replace text with input
                textElement.style.display = 'none';
                textElement.parentNode.insertBefore(input, textElement);
                
                // Focus and select text
                input.focus();
                input.select();
                
                // Handle save on Enter or blur
                const saveEdit = async () => {
                    const newText = input.value.trim();
                    if (newText && newText !== currentText) {
                        await this.updateSubtaskText(todoId, subtaskId, newText);
                    }
                    // Restore text element
                    textElement.textContent = newText || currentText;
                    textElement.style.display = '';
                    input.remove();
                };
                
                const cancelEdit = () => {
                    textElement.style.display = '';
                    input.remove();
                };
                
                input.addEventListener('blur', saveEdit);
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        saveEdit();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        cancelEdit();
                    }
                });
            }

            async updateSubtaskText(todoId, subtaskId, newText) {
                const todo = this.todos.find(t => t.id === todoId);
                if (!todo || !this.todosRef) return;

                const subtasks = todo.subtasks || [];
                const subtask = subtasks.find(s => s.id === subtaskId);
                if (!subtask) return;

                subtask.text = newText;

                // Update local state immediately
                todo.subtasks = subtasks;

                const todoRef = ref(database, `users/${this.user.uid}/todos/${todoId}`);
                await update(todoRef, { subtasks: subtasks });
                
                // Re-render subtasks immediately
                this.renderSubtasks(todoId, subtasks);
            }

            renderTodos() {
                // Track which sublists are currently open before re-rendering
                const openSublists = new Set();
                document.querySelectorAll('.sublist-container').forEach(container => {
                    if (container.style.display !== 'none' && container.id) {
                        const todoId = container.id.replace('sublist-', '');
                        if (todoId) {
                            openSublists.add(todoId);
                        }
                    }
                });

                const importantTodos = this.todos
                    .filter(todo => todo.important && !todo.completed)
                    .sort((a, b) => (a.order || 0) - (b.order || 0));

                const regularTodos = this.todos
                    .filter(todo => !todo.important && !todo.completed)
                    .sort((a, b) => (a.order || 0) - (b.order || 0));

                // Show/hide Important Tasks section based on whether there are important todos
                const importantSection = document.querySelector('.todos-section:first-of-type');
                if (importantTodos.length === 0) {
                    importantSection.style.display = 'none';
                } else {
                    importantSection.style.display = 'block';
                }

                // Count non-completed todos to determine if we should show empty state
                const activeTodos = this.todos.filter(todo => !todo.completed);
                
                // Show/hide All Tasks section based on whether there are any active todos
                const allTasksSection = document.querySelector('.todos-section:last-of-type');
                if (activeTodos.length === 0) {
                    allTasksSection.style.display = 'none';
                } else {
                    allTasksSection.style.display = 'block';
                }

                this.renderTodoList(importantTodos, this.importantTodos, true);
                this.renderTodoList(regularTodos, this.allTodos, false);

                // Restore open sublists after re-rendering
                openSublists.forEach(todoId => {
                    const sublistContainer = document.getElementById(`sublist-${todoId}`);
                    const sublistBtn = document.querySelector(`[onclick="app.toggleSublist('${todoId}')"]`);
                    if (sublistContainer && sublistBtn) {
                        sublistContainer.style.display = 'block';
                        sublistBtn.classList.add('active');
                        // Re-render subtasks if the todo still exists
                        const todo = this.todos.find(t => t.id === todoId);
                        if (todo && todo.subtasks) {
                            this.renderSubtasks(todoId, todo.subtasks);
                        }
                    }
                });

                // Show/hide todos container and empty state based on active todos
                if (activeTodos.length === 0) {
                    // Hide todos container and show empty state
                    if (this.todosContainer) {
                        this.todosContainer.style.display = 'none';
                    }
                    this.emptyState.style.display = 'block';
                } else {
                    // Show todos container and hide empty state
                    if (this.todosContainer) {
                        this.todosContainer.style.display = 'flex';
                    }
                    this.emptyState.style.display = 'none';
                }
            }

            renderTodoList(todos, container, isImportant) {
                container.innerHTML = '';

                todos.forEach(todo => {
                    const todoElement = this.createTodoElement(todo, isImportant);
                    container.appendChild(todoElement);
                });

                // Make the list sortable
                this.makeSortable(container, isImportant);
            }

            createTodoElement(todo, isImportant) {
                const todoDiv = document.createElement('div');
                todoDiv.className = `todo-item ${todo.completed ? 'completed' : ''}`;
                todoDiv.draggable = true;
                todoDiv.dataset.todoId = todo.id;

                const subtasks = todo.subtasks || [];
                // Only count non-crossed-out subtasks
                const activeSubtasks = subtasks.filter(subtask => !subtask.crossedOut);
                const completedSubtasks = activeSubtasks.filter(subtask => subtask.completed).length;
                const hasSubtasks = activeSubtasks.length > 0;

                todoDiv.innerHTML = `
                    <div class="todo-content">
                        <button class="complete-btn ${todo.completed ? 'completed' : ''}" 
                                onclick="app.toggleCompleted('${todo.id}')">
                            <i class="fas fa-check"></i>
                        </button>
                        <span class="todo-text" ondblclick="app.startEditTodo('${todo.id}')" title="Double-click to edit">${this.escapeHtml(todo.text)}</span>
                        <div class="todo-actions">
                            <button class="sublist-btn ${hasSubtasks ? 'has-sublist' : ''}" 
                                    onclick="app.toggleSublist('${todo.id}')" 
                                    title="${hasSubtasks ? 'View sublist' : 'Create sublist'}">
                                <i class="fas fa-list"></i>
                                ${hasSubtasks ? `<span class="sublist-count">${completedSubtasks}/${activeSubtasks.length}</span>` : ''}
                            </button>
                            <button class="important-btn ${todo.important ? 'important' : ''}" 
                                    onclick="app.toggleImportant('${todo.id}')" 
                                    title="${todo.important ? 'Remove from important' : 'Mark as important'}">
                                <i class="fas fa-star"></i>
                            </button>
                            <button class="delete-btn" onclick="app.deleteTodo('${todo.id}')" title="Delete task">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                    <div class="sublist-container" id="sublist-${todo.id}" style="display: none;">
                        <div class="sublist-header">
                            <h4>Steps to complete this task:</h4>
                        </div>
                        <div class="sublist-input">
                            <input type="text" id="subtaskInput-${todo.id}" placeholder="Add a step...">
                            <button onclick="app.addSubtask('${todo.id}')" class="add-subtask-btn">
                                <i class="fas fa-plus"></i>
                            </button>
                        </div>
                        <div class="sublist-items" id="sublistItems-${todo.id}">
                            <!-- Subtasks will be added here -->
                        </div>
                    </div>
                `;

                // Render existing subtasks
                if (hasSubtasks) {
                    this.renderSubtasks(todo.id, subtasks);
                }

                return todoDiv;
            }

            makeSortable(container, isImportant) {
                let draggedElement = null;
                let dragOverElement = null;

                container.addEventListener('dragstart', (e) => {
                    // Only allow dragging of todo items, not buttons or other elements
                    if (!e.target.classList.contains('todo-item')) {
                        e.preventDefault();
                        return;
                    }
                    
                    draggedElement = e.target;
                    e.target.classList.add('dragging');
                    e.target.style.opacity = '0.5';
                    
                    // Set drag effect
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', e.target.outerHTML);
                });

                container.addEventListener('dragend', (e) => {
                    e.target.classList.remove('dragging');
                    e.target.style.opacity = '1';
                    draggedElement = null;
                    
                    // Remove any drag over indicators
                    container.querySelectorAll('.drag-over').forEach(el => {
                        el.classList.remove('drag-over');
                    });
                });

                container.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    if (!draggedElement) return;
                    
                    const afterElement = this.getDragAfterElement(container, e.clientY);
                    
                    // Remove previous drag over indicators
                    container.querySelectorAll('.drag-over').forEach(el => {
                        el.classList.remove('drag-over');
                    });
                    
                    // Add drag over indicator to the element we're hovering over
                    if (afterElement) {
                        afterElement.classList.add('drag-over');
                    }
                    
                    // Move the dragged element
                    if (afterElement == null) {
                        container.appendChild(draggedElement);
                    } else {
                        container.insertBefore(draggedElement, afterElement);
                    }
                });

                container.addEventListener('dragenter', (e) => {
                    e.preventDefault();
                    if (e.target.classList.contains('todo-item') && e.target !== draggedElement) {
                        e.target.classList.add('drag-over');
                    }
                });

                container.addEventListener('dragleave', (e) => {
                    if (e.target.classList.contains('todo-item')) {
                        e.target.classList.remove('drag-over');
                    }
                });

                container.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    if (!draggedElement) return;

                    // Remove all drag over indicators
                    container.querySelectorAll('.drag-over').forEach(el => {
                        el.classList.remove('drag-over');
                    });

                    const todos = Array.from(container.children);
                    const newIndex = todos.indexOf(draggedElement);
                    
                    // Update order for all todos in this section
                    for (let i = 0; i < todos.length; i++) {
                        const todoId = todos[i].dataset.todoId;
                        await this.updateOrder(todoId, i);
                    }
                });
            }

            getDragAfterElement(container, y) {
                const draggableElements = [...container.querySelectorAll('.todo-item:not(.dragging)')];
                
                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;
                    
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }

            updateStats() {
                // Only count non-completed todos for the total
                const total = this.todos.filter(todo => !todo.completed).length;
                const important = this.todos.filter(todo => todo.important && !todo.completed).length;
                const all = this.todos.filter(todo => !todo.completed).length;

                this.totalTodos.textContent = total;
                this.importantCount.textContent = important;
                this.allCount.textContent = all;
            }

            showLoading(show) {
                this.loadingOverlay.style.display = show ? 'flex' : 'none';
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            showAppError(message) {
                this.appError.textContent = message;
                this.appError.style.display = 'block';
                // Auto-hide after 10 seconds
                setTimeout(() => {
                    this.appError.style.display = 'none';
                }, 10000);
            }

            hideAppError() {
                this.appError.style.display = 'none';
            }
        }

        // Initialize the app
        window.app = new TodoApp();
    </script>
</body>
</html>
